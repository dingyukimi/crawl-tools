//    hdu5033 Building åè°éå
//
//    é¢ç®å¤§æï¼
//
//    næ å¤§æ¥¼ï¼æä¸ä¸ªé«åº¦håä½ç½®xï¼ç°å¨æä¸ä¸ªäººé«åº¦ä¸º0ï¼æqä¸ªè¯¢é®
//    æ¯ä¸ªè¯¢é®æä¸ä¸ªä½ç½®xï¼æ±å¨ä½ç½®xè½çå°å¤©ç©ºçæå¤§çè§åº¦ã
//
//    è§£é¢æè·¯ï¼
//
//    é¦åå¾æ³å°å°qä¸ªè¯¢é®çä½ç½®ä½ä¸ºä¸æ å¤§æ¥¼æ¾å¨æ´ä¸ªå¤§æ¥¼ä¸­èèï¼è¿æ ·
//    é®é¢å°±æ¯è¾ä¸è´ï¼ä¹æ¯è¾å®¹æå¤çå¦ã
//
//    æ³è±¡ä¸ä¸ï¼æ¯æ¬¡ä»å·¦å¾å³èµ°ï¼å¯¹äºå½åä½ç½®çå·¦åè¾¹ç90åº¦åï¼çå¤©çè§åº¦æ¯
//    éæ¸åå°çï¼è¿æ ·ï¼å¦æå½åä½ç½®çå·¦è¾¹æ¯å½åä½ç½®è¦ä½ï¼é£ä¹å½åä½ç½®å°±æ¡ä½äº
//    ä¹åçæ´ç®çï¼ä¹å°±æ¯è¯´ä¹åçä½ç½®æ¯ä¸å¯è½çå°æ¯å½åæ´ç®çå¤§æ¥¼äºï¼è¿æ ·ï¼å°±å¯
//    ä»¥çææ¯ä¸ä¸ªåè°çåºåï¼åºåä¸­åç´ é«åº¦åè°éåï¼å³æè°çåè°éåãä½ä»ä»åªæ¯
//    è¿æ ·æ¯ä¸å¤çï¼ä¹ä¼å­å¨æ¯å½ååç´ (è®¾ä¸ºh)é«è®¾ä¸ºh1ï¼å¨éåä¸­h1åé¢çåç´ æ¯h2ï¼è½ç¶
//    h1æ¯æ¯hå¤§ï¼ä½æ¯å¦æé¡ºçh1çé«åº¦çè¿å»ï¼ä¼è¢«h2æ¡ä½ï¼è¿æ¶h1æ¯æ²¡æä½ç¨çï¼ä¹è¦å°
//    è¿ä¸ªåç´ ä»éåä¸­ç§»é¤ã
//
//    å½éå°çå¤§æ¥¼è¦æ¥è¯¢çä½ç½®çæ¶åï¼æ­¤æ¶éåæåçä¸ä¸ªåç´ å¹¶ä¸ä¸å®æ¯æä¼çå¼ï¼å ä¸º
//    è¿æ ·çå¼å¯è½æ¯ä¸åæ³çï¼æ¯å¦ä¸é¢çh1ä¼è¢«h2æ¡ä½ï¼å¹¶ä¸ä¼çå°å¤©ç©ºãç§æ ·ç§»é¤è¿æ ·çåç´ 
//    æåï¼éåçæåä¸ä¸ªåç´ å°±æ¯è§£ã
//
//    å³è¾¹çé®é¢å®å¨å¯ä»¥è½¬åä¸ºå·¦è¾¹çé®é¢ï¼åªæ¯ä»å³å¾å·¦å¤çèå·²ã
//
//
//    ææï¼
//
//    è¿éé¢æ¯14å¹´åäº¬åºçç½èµçä¸éé¢ç®ï¼å½æ¶çæè½ç¶çæäºé¢ç®çææï¼ä½æ¯ççå®å¨ä¸ä¼åã
//    ç´å°ç°å¨ä¼å¤§çMWå¤§åï¼è¯´æ¯åè°éåå¯ä»¥åï¼æå°±åäºï¼ä½æ¯å¡äºä¸å¤©åï¼è¿æ¯æ³ä¸åºæ¥å·ä½æä¹è§£
//    é¦åå°è¯¢é®çä½ç½®å½ä½å¤§æ¥¼è¿ä¸ç¹ææ³å°äºï¼ç»´æé«åº¦éåçåè°éåææ³å°äºï¼å°±æ¯æåä¸ç§æåµæ²¡æ
//    æ³å°ï¼æ´ä¸ç¥éè¦æä¹å¤çï¼å¨ä¼å¤§çMWå¤§åçæ¦æ¦æè¯²è¿æèå¿çæç¤ºä¸ï¼ç»äºç»äºæ³å°äºè§£å³çåæ³
//    ä¸å®¹æåä¸å®¹æãå¨æ­¤çè¯æè°¢MWå¤§å~
//
//    è¿ç¨æ çä¼æå¾å¤ççæï¼ä¸ä¸ªå°æ¹ä¸æï¼æ»¡ççè¾ï¼æ¾å°ä¸å¤çéè¯¯ï¼å¿éååçæ¬£åï¼ç¹å«æ¯å¨ac
//    ä¹åï¼é£ç§å¿æï¼å®å¨æ¯é¾ä»¥æè¿°ï¼æè§å°èªå·±çä»åºï¼ççæ¯æåæ¥ï¼ä»¥åä¸æçä¸è¥¿ï¼èªå·±è®¤çå­¦
//    æ»ä¼ææ¶è·ï¼åªææ¶è·æ¯é£ä¹ä¸ç¹ç¹ï¼å¾®ä¸è¶³éï¼ä½æ¶è·å°±æ¯æ¶è·ï¼æ²¡æè¿ä¸ªè½è®©äººæ´å æ¬£åå¦ï¼çè¦å¹¶å¿«ä¹ç
//    ååçäº«åï¼è¿æ¯é£å¥è¯ï¼ç»§ç»­ç»å§~~~




#include <cstdio>
#include <algorithm>
#include <cmath>
#include <iostream>
#include <cstring>
using namespace std;

const int MAX_N = 2e5 + 9;

const double PI = acos(-1.0);
int n,q;
double deqh[MAX_N];
double deqx[MAX_N];
double angle[MAX_N];

struct node {
    double pos;
    double h;
    int id;

    node(){

    }

    node(double pos,double h,int id):pos(pos),h(h),id(id){

    }
};

node sky[MAX_N];

bool cmp(node a,node b){
    return a.pos < b.pos;
}

void input(){
    scanf("%d",&n);
    double x,h;
    for (int i = 1;i <= n;i++){
        scanf("%lf%lf",&x,&h);
        sky[i] = node(x,h,0);
    }
    scanf("%d",&q);

    for (int i = 1;i <= q;i++){
        scanf("%lf",&x);
        sky[i+n] = node(x,0.0,i);
        angle[i] = 0.0;
    }

    n += q;

    sort(sky+1,sky+n+1,cmp);
}

double getk(double a,double b){
    return fabs(a/b);
}

void getleft(){
    int head,tail;
    head = tail = 0;
    for (int i=1;i<=n;i++){
        if (sky[i].id){
            while(head + 1 < tail){
                double k1 = getk(deqh[tail-1],deqx[tail-1]-sky[i].pos);
                double k2 = getk(deqh[tail-2],deqx[tail-2]-sky[i].pos);
                if (k1 <= k2)
                    tail--;
                else break;
            }
            angle[sky[i].id] += atan(deqh[tail-1]/fabs(deqx[tail-1]-sky[i].pos));
        }else {

            while(head < tail && deqh[tail-1] < sky[i].h)
                tail--;

            while(head + 1 < tail){
                double k1 = getk(deqh[tail-1]-sky[i].h,deqx[tail-1]-sky[i].pos);
                double k2 = getk(deqh[tail-2]-sky[i].h,deqx[tail-2]-sky[i].pos);
                if (k1 <= k2)
                    tail--;
                else
                    break;
            }
            deqh[tail] = sky[i].h;
            deqx[tail++] = sky[i].pos;
        }
    }
}

void getright(){
    int head,tail;
    head = tail = 0;
    for (int i = n;i >= 1;i--){
        if (sky[i].id){
            while(head + 1 < tail){
                double k1 = getk(deqh[tail-1],deqx[tail-1]-sky[i].pos);
                double k2 = getk(deqh[tail-2],deqx[tail-2]-sky[i].pos);
                if (k1 <= k2)
                    tail--;
                else
                    break;
            }

            angle[sky[i].id] += atan(deqh[tail-1]/fabs(deqx[tail-1]-sky[i].pos));


        }else {
            while(head < tail && deqh[tail-1] < sky[i].h)
                tail--;

            while(head + 1 < tail){

                double k1 = getk(deqh[tail-1]-sky[i].h,deqx[tail-1] - sky[i].pos);
                double k2 = getk(deqh[tail-2]-sky[i].h,deqx[tail-2] - sky[i].pos);

                if (k1 <= k2){
                    tail--;
                }else
                    break;

            }
            deqh[tail] = sky[i].h;
            deqx[tail++] = sky[i].pos;
        }
    }
}

void solve(){
    getleft();
    getright();
    for (int i=1;i<=q;i++){
        printf("%.10lf\n",(PI - angle[i]) * 180.0 / PI);
    }
}


int main(){
    int t;
    //freopen("1.txt","r",stdin);
    scanf("%d",&t);
    int kase = 1;
    while(t--){
        input();
        printf("Case #%d:\n",kase++);
        solve();
    }
}
